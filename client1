import pygame
import socket
import threading
import pickle

HOST = 'SERVER_IP_HERE'
PORT = 5000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

# Infinite grid storage
pixels = {}  # {(x, y): color}
lock = threading.Lock()

def recv_thread():
    global pixels
    while True:
        try:
            data = s.recv(4096)
            if data:
                x, y, color = pickle.loads(data)
                with lock:
                    pixels[(x, y)] = color
        except:
            break

threading.Thread(target=recv_thread, daemon=True).start()

# Pygame setup
pygame.init()
screen = pygame.display.set_mode((800, 600))
clock = pygame.time.Clock()
current_color = (255, 0, 0)
BASE_PIXEL_SIZE = 20
cam_x = cam_y = 0

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mx, my = pygame.mouse.get_pos()
            gx = (mx + cam_x) // BASE_PIXEL_SIZE
            gy = (my + cam_y) // BASE_PIXEL_SIZE
            data = pickle.dumps((gx, gy, current_color))
            s.sendall(data)
            with lock:
                pixels[(gx, gy)] = current_color

    screen.fill((255, 255, 255))
    with lock:
        for (gx, gy), color in pixels.items():
            px = gx * BASE_PIXEL_SIZE - cam_x
            py = gy * BASE_PIXEL_SIZE - cam_y
            pygame.draw.rect(screen, color, (px, py, BASE_PIXEL_SIZE, BASE_PIXEL_SIZE))

    pygame.display.flip()
    clock.tick(60)

